diff --git a/gfx/angle/checkout/include/EGL/eglplatform.h b/gfx/angle/checkout/include/EGL/eglplatform.h
index 9ebaf00a9b..59b65acd7f 100644
--- a/gfx/angle/checkout/include/EGL/eglplatform.h
+++ b/gfx/angle/checkout/include/EGL/eglplatform.h
@@ -109,7 +109,7 @@ typedef intptr_t EGLNativeDisplayType;
 typedef intptr_t EGLNativePixmapType;
 typedef intptr_t EGLNativeWindowType;
 
-#elif defined(__unix__) && defined(EGL_NO_X11)
+#elif defined(__unix__)
 
 typedef void             *EGLNativeDisplayType;
 typedef khronos_uintptr_t EGLNativePixmapType;
diff --git a/gfx/cairo/cairo/src/cairo-features.h b/gfx/cairo/cairo/src/cairo-features.h
index cfed9d9a2f..fd1eb869d3 100644
--- a/gfx/cairo/cairo/src/cairo-features.h
+++ b/gfx/cairo/cairo/src/cairo-features.h
@@ -55,8 +55,8 @@
 #define CAIRO_HAS_PDF_SURFACE 1
 #endif
 
-#ifdef MOZ_X11
 #define CAIRO_HAS_PS_SURFACE 1
+#ifdef MOZ_X11
 #define CAIRO_HAS_XLIB_XRENDER_SURFACE 0
 #define CAIRO_HAS_XLIB_SURFACE 1
 #endif
diff --git a/gfx/gl/GLContextProvider.h b/gfx/gl/GLContextProvider.h
index 12d1a497b9..d30b01c144 100644
--- a/gfx/gl/GLContextProvider.h
+++ b/gfx/gl/GLContextProvider.h
@@ -55,17 +55,18 @@ namespace gl {
 #  define GL_CONTEXT_PROVIDER_NAME GLContextProviderX11
 #  include "GLContextProviderImpl.h"
 #  undef GL_CONTEXT_PROVIDER_NAME
-#  if defined(MOZ_WAYLAND)
-#    define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
-#    include "GLContextProviderImpl.h"
-#    undef GL_CONTEXT_PROVIDER_NAME
-#    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
-#  endif
 #  ifndef GL_CONTEXT_PROVIDER_DEFAULT
 #    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderX11
 #  endif
 #endif
 
+#if defined(MOZ_WAYLAND)
+#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
+#  include "GLContextProviderImpl.h"
+#  undef GL_CONTEXT_PROVIDER_NAME
+#  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
+#endif
+
 #ifndef GL_CONTEXT_PROVIDER_DEFAULT
 #  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderEGL
 #endif
diff --git a/gfx/gl/GLContextProviderWayland.cpp b/gfx/gl/GLContextProviderWayland.cpp
index 3f1f926cd9..cd49dc5f17 100644
--- a/gfx/gl/GLContextProviderWayland.cpp
+++ b/gfx/gl/GLContextProviderWayland.cpp
@@ -14,7 +14,6 @@ namespace mozilla::gl {
 using namespace mozilla::gfx;
 using namespace mozilla::widget;
 
-static class GLContextProviderX11 sGLContextProviderX11;
 static class GLContextProviderEGL sGLContextProviderEGL;
 
 // Note that if there is no GTK display, `GdkIsX11Display` and
@@ -30,41 +29,24 @@ static class GLContextProviderEGL sGLContextProviderEGL;
 already_AddRefed<GLContext> GLContextProviderWayland::CreateForCompositorWidget(
     CompositorWidget* aCompositorWidget, bool aHardwareWebRender,
     bool aForceAccelerated) {
-  if (GdkIsWaylandDisplay()) {
     return sGLContextProviderEGL.CreateForCompositorWidget(
         aCompositorWidget, aHardwareWebRender, aForceAccelerated);
-  } else {
-    return sGLContextProviderX11.CreateForCompositorWidget(
-        aCompositorWidget, aHardwareWebRender, aForceAccelerated);
-  }
 }
 
 /*static*/
 already_AddRefed<GLContext> GLContextProviderWayland::CreateHeadless(
     const GLContextCreateDesc& desc, nsACString* const out_failureId) {
-  if (GdkIsWaylandDisplay()) {
     return sGLContextProviderEGL.CreateHeadless(desc, out_failureId);
-  } else {
-    return sGLContextProviderX11.CreateHeadless(desc, out_failureId);
-  }
 }
 
 /*static*/
 GLContext* GLContextProviderWayland::GetGlobalContext() {
-  if (GdkIsWaylandDisplay()) {
     return sGLContextProviderEGL.GetGlobalContext();
-  } else {
-    return sGLContextProviderX11.GetGlobalContext();
-  }
 }
 
 /*static*/
 void GLContextProviderWayland::Shutdown() {
-  if (GdkIsWaylandDisplay()) {
     sGLContextProviderEGL.Shutdown();
-  } else {
-    sGLContextProviderX11.Shutdown();
-  }
 }
 
 }  // namespace mozilla::gl
diff --git a/gfx/gl/moz.build b/gfx/gl/moz.build
index 7ac6b0753a..a817a6fb08 100644
--- a/gfx/gl/moz.build
+++ b/gfx/gl/moz.build
@@ -13,7 +13,7 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "cocoa":
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "uikit":
     gl_provider = "EAGL"
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
-    if CONFIG["MOZ_EGL_XRENDER_COMPOSITE"]:
+    if CONFIG["MOZ_EGL_XRENDER_COMPOSITE"] or CONFIG["MOZ_WAYLAND"]:
         gl_provider = "EGL"
     else:
         gl_provider = "GLX"
diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
index 1b46a2aab8..238680c2ac 100644
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -31,7 +31,6 @@
 #include "mozilla/FontPropertyTypes.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/Logging.h"
-#include "mozilla/gfx/XlibDisplay.h"
 #include "mozilla/Monitor.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/StaticPrefs_gfx.h"
@@ -65,6 +64,7 @@
 #  include "mozilla/widget/nsWaylandDisplay.h"
 #  include "mozilla/widget/DMABufLibWrapper.h"
 #  include "mozilla/StaticPrefs_widget.h"
+#  include "mozilla/WidgetUtilsGtk.h"
 #endif
 
 #define GDK_PIXMAP_SIZE_MAX 32767
@@ -100,7 +100,7 @@ gfxPlatformGtk::gfxPlatformGtk() {
   }
 
   mMaxGenericSubstitutions = UNINITIALIZED_VALUE;
-  mIsX11Display = gfxPlatform::IsHeadless() ? false : GdkIsX11Display();
+  mIsX11Display = false;
   if (XRE_IsParentProcess()) {
     InitX11EGLConfig();
     if (IsWaylandDisplay() || gfxConfig::IsEnabled(Feature::X11_EGL)) {
@@ -127,7 +127,6 @@ gfxPlatformGtk::gfxPlatformGtk() {
 
   // Bug 1714483: Force disable FXAA Antialiasing on NV drivers. This is a
   // temporary workaround for a driver bug.
-  PR_SetEnv("__GL_ALLOW_FXAA_USAGE=0");
 }
 
 gfxPlatformGtk::~gfxPlatformGtk() {
diff --git a/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp b/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
index cf3fc3c2ca..7cb5b573c1 100644
--- a/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
+++ b/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
@@ -27,7 +27,7 @@
 #ifdef MOZ_WIDGET_GTK
 #  include "mozilla/widget/GtkCompositorWidget.h"
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
+#  include <gdk/gdkwayland.h>
 #endif
 
 namespace mozilla {
diff --git a/toolkit/components/remote/moz.build b/toolkit/components/remote/moz.build
index c1853a9f4d..cb6b7f0a9c 100644
--- a/toolkit/components/remote/moz.build
+++ b/toolkit/components/remote/moz.build
@@ -26,12 +26,6 @@ if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
             "nsUnixRemoteServer.h",
             "RemoteUtils.h",
         ]
-    else:
-        SOURCES += [
-            "nsGTKRemoteServer.cpp",
-            "nsXRemoteClient.cpp",
-            "nsXRemoteServer.cpp",
-        ]
     CXXFLAGS += CONFIG["TK_CFLAGS"]
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "windows":
diff --git a/toolkit/components/remote/nsRemoteService.cpp b/toolkit/components/remote/nsRemoteService.cpp
index b2499d8191..0a1c729570 100644
--- a/toolkit/components/remote/nsRemoteService.cpp
+++ b/toolkit/components/remote/nsRemoteService.cpp
@@ -12,13 +12,18 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include "mozilla/WidgetUtilsGtk.h"
-#  include "nsGTKRemoteServer.h"
 #  ifdef MOZ_ENABLE_DBUS
 #    include "nsDBusRemoteServer.h"
 #    include "nsDBusRemoteClient.h"
-#  else
+#  endif
+#  ifdef MOZ_X11
+#    include "nsGTKRemoteServer.h"
 #    include "nsXRemoteClient.h"
 #  endif
+#  ifdef MOZ_WAYLAND
+#    include <gdk/gdkwayland.h>
+#    include "nsRemoteClient.h"
+#  endif
 #elif defined(XP_WIN)
 #  include "nsWinRemoteServer.h"
 #  include "nsWinRemoteClient.h"
@@ -98,11 +103,12 @@ RemoteResult nsRemoteService::StartClient(const char* aDesktopStartupID) {
     return REMOTE_NOT_FOUND;
   }
 
+  return REMOTE_NOT_FOUND;
   UniquePtr<nsRemoteClient> client;
 #ifdef MOZ_WIDGET_GTK
 #  if defined(MOZ_ENABLE_DBUS)
   client = MakeUnique<nsDBusRemoteClient>();
-#  else
+#  elif defined(MOZ_X11)
   client = MakeUnique<nsXRemoteClient>();
 #  endif
 #elif defined(XP_WIN)
@@ -143,10 +149,11 @@ void nsRemoteService::StartupServer() {
     return;
   }
 
+  return;
 #ifdef MOZ_WIDGET_GTK
 #  if defined(MOZ_ENABLE_DBUS)
   mRemoteServer = MakeUnique<nsDBusRemoteServer>();
-#  else
+#  elif defined(MOZ_X11)
   mRemoteServer = MakeUnique<nsGTKRemoteServer>();
 #  endif
 #elif defined(XP_WIN)
diff --git a/toolkit/moz.configure b/toolkit/moz.configure
index a78a32bdc0..d6bed82e1b 100644
--- a/toolkit/moz.configure
+++ b/toolkit/moz.configure
@@ -1170,35 +1170,6 @@ set_define("MOZ_RAW", depends_if("--enable-raw")(lambda _: True))
 
 # X11
 # ==============================================================
-set_config("MOZ_X11", True, when=toolkit_gtk)
-set_define("MOZ_X11", True, when=toolkit_gtk)
-
-
-@depends(webrtc, when=toolkit_gtk)
-def x11_libs(webrtc):
-    libs = [
-        "x11",
-        "xcb",
-        "xcb-shm",
-        "x11-xcb",
-        "xext",
-        "xrandr >= 1.4.0",
-    ]
-    if webrtc:
-        # third_party/libwebrtc/webrtc/webrtc_gn/moz.build adds those
-        # manually, ensure they're available.
-        libs += [
-            "xcomposite",
-            "xcursor",
-            "xdamage",
-            "xfixes",
-            "xi",
-        ]
-    return libs
-
-
-pkg_check_modules("MOZ_X11", x11_libs, when=toolkit_gtk)
-pkg_check_modules("MOZ_X11_SM", ["ice", "sm"], cflags_only=True, when=toolkit_gtk)
 
 
 # ASan Reporter Addon
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index 60ea6966cc..01ea1a8774 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -346,7 +346,6 @@ void XRE_LibFuzzerSetDriver(LibFuzzerDriver aDriver) {
 #endif  // FUZZING
 
 // Undo X11/X.h's definition of None
-#undef None
 
 namespace mozilla {
 int (*RunGTest)(int*, char**) = 0;
diff --git a/toolkit/xre/nsGDKErrorHandler.cpp b/toolkit/xre/nsGDKErrorHandler.cpp
index 421abdf12f..7727f0f3e7 100644
--- a/toolkit/xre/nsGDKErrorHandler.cpp
+++ b/toolkit/xre/nsGDKErrorHandler.cpp
@@ -6,14 +6,13 @@
 #include "nsGDKErrorHandler.h"
 
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
 #include "nsDebug.h"
 #include "nsString.h"
-#include "nsX11ErrorHandler.h"
 
 #include "prenv.h"
 
@@ -26,6 +25,7 @@
  */
 static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
                             const gchar* message, gpointer user_data) {
+#ifdef MOZ_X11
   if (strstr(message, "X Window System error")) {
     XErrorEvent event;
     nsDependentCString buffer(message);
@@ -93,9 +93,12 @@ static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
 
     X11Error(event.display, &event);
   } else {
+#endif
     g_log_default_handler(log_domain, log_level, message, user_data);
     MOZ_CRASH_UNSAFE(message);
+#ifdef MOZ_X11
   }
+#endif
 }
 
 void InstallGdkErrorHandler() {
@@ -103,7 +106,9 @@ void InstallGdkErrorHandler() {
                     (GLogLevelFlags)(G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL |
                                      G_LOG_FLAG_RECURSION),
                     GdkErrorHandler, nullptr);
+#ifdef MOZ_X11
   if (PR_GetEnv("MOZ_X_SYNC")) {
     XSynchronize(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), X11True);
   }
+#endif
 }
diff --git a/widget/CompositorWidget.h b/widget/CompositorWidget.h
index 20eb3634f3..10fb94a99f 100644
--- a/widget/CompositorWidget.h
+++ b/widget/CompositorWidget.h
@@ -62,7 +62,7 @@ class CompositorWidgetDelegate {
 };
 
 // Platforms that support out-of-process widgets.
-#if defined(XP_WIN) || defined(MOZ_X11)
+#if defined(XP_WIN) || defined(MOZ_X11) || defined(MOZ_WAYLAND)
 // CompositorWidgetParent should implement CompositorWidget and
 // PCompositorWidgetParent.
 class CompositorWidgetParent;
diff --git a/widget/gtk/GtkCompositorWidget.cpp b/widget/gtk/GtkCompositorWidget.cpp
index 89a8248bc0..38b0a14028 100644
--- a/widget/gtk/GtkCompositorWidget.cpp
+++ b/widget/gtk/GtkCompositorWidget.cpp
@@ -49,9 +49,9 @@ GtkCompositorWidget::GtkCompositorWidget(
   auto size = mClientSize.Lock();
   *size = aInitData.InitialClientSize();
 
-  LOG("GtkCompositorWidget::GtkCompositorWidget() [%p] mXWindow %p "
+  LOG("GtkCompositorWidget::GtkCompositorWidget() [%p] "
       "mIsRenderingSuspended %d\n",
-      (void*)mWidget.get(), (void*)mXWindow, !!mIsRenderingSuspended);
+      (void*)mWidget.get(), !!mIsRenderingSuspended);
 }
 
 GtkCompositorWidget::~GtkCompositorWidget() {
diff --git a/widget/gtk/MozContainer.cpp b/widget/gtk/MozContainer.cpp
index 95832dc03d..8a92ec88dc 100644
--- a/widget/gtk/MozContainer.cpp
+++ b/widget/gtk/MozContainer.cpp
@@ -9,7 +9,7 @@
 
 #include <glib.h>
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
 #include <stdio.h>
 #include "mozilla/WidgetUtilsGtk.h"
 
diff --git a/widget/gtk/components.conf b/widget/gtk/components.conf
index 38c07bd812..a125d8d275 100644
--- a/widget/gtk/components.conf
+++ b/widget/gtk/components.conf
@@ -78,7 +78,7 @@ Classes = [
     },
 ]
 
-if defined('MOZ_X11'):
+if defined('MOZ_X11') or defined('MOZ_WAYLAND'):
     Classes += [
         {
             'js_name': 'clipboard',
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index 291e3a78c8..7955b84d0c 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -101,22 +101,26 @@ if CONFIG["MOZ_WAYLAND"]:
 
 if CONFIG["MOZ_X11"]:
     UNIFIED_SOURCES += [
-        "CompositorWidgetChild.cpp",
-        "CompositorWidgetParent.cpp",
-        "InProcessGtkCompositorWidget.cpp",
         "nsClipboardX11.cpp",
         "nsShmImage.cpp",
-        "nsUserIdleServiceGTK.cpp",
         "WindowSurfaceX11.cpp",
         "WindowSurfaceX11Image.cpp",
         "WindowSurfaceX11SHM.cpp",
     ]
-    EXPORTS.mozilla.widget += [
-        "CompositorWidgetChild.h",
-        "CompositorWidgetParent.h",
-        "GtkCompositorWidget.h",
-        "InProcessGtkCompositorWidget.h",
-    ]
+
+UNIFIED_SOURCES += [
+    "CompositorWidgetChild.cpp",
+    "CompositorWidgetParent.cpp",
+    "InProcessGtkCompositorWidget.cpp",
+    "nsUserIdleServiceGTK.cpp",
+]
+
+EXPORTS.mozilla.widget += [
+    "CompositorWidgetChild.h",
+    "CompositorWidgetParent.h",
+    "GtkCompositorWidget.h",
+    "InProcessGtkCompositorWidget.h",
+]
 
 if CONFIG["NS_PRINTING"]:
     UNIFIED_SOURCES += [
@@ -145,7 +149,7 @@ LOCAL_INCLUDES += [
     "/widget/headless",
 ]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     LOCAL_INCLUDES += [
         "/widget/x11",
     ]
diff --git a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
index 677f9b3561..7120c83352 100644
--- a/widget/gtk/mozgtk/mozgtk.c
+++ b/widget/gtk/mozgtk/mozgtk.c
@@ -6,7 +6,6 @@
 
 #include "mozilla/Types.h"
 
-#include <X11/Xlib.h>
 // Bug 1271100
 // We need to trick system Cairo into not using the XShm extension due to
 // a race condition in it that results in frequent BadAccess errors. Cairo
@@ -18,4 +17,3 @@
 // This is also used to force libxul to depend on the mozgtk library. If we
 // ever can remove this workaround for system Cairo, we'll need something
 // to replace it for that purpose.
-MOZ_EXPORT Bool XShmQueryExtension(Display* aDisplay) { return False; }
diff --git a/widget/gtk/nsClipboard.cpp b/widget/gtk/nsClipboard.cpp
index ed15e549de..77fe18509c 100644
--- a/widget/gtk/nsClipboard.cpp
+++ b/widget/gtk/nsClipboard.cpp
@@ -9,7 +9,6 @@
 
 #include "nsArrayUtils.h"
 #include "nsClipboard.h"
-#include "nsClipboardX11.h"
 #if defined(MOZ_WAYLAND)
 #  include "nsClipboardWayland.h"
 #  include "nsClipboardWaylandAsync.h"
@@ -37,7 +36,6 @@
 #include "imgIContainer.h"
 
 #include <gtk/gtk.h>
-#include <gtk/gtkx.h>
 
 #include "mozilla/Encoding.h"
 
@@ -106,16 +104,12 @@ nsClipboard::~nsClipboard() {
 NS_IMPL_ISUPPORTS(nsClipboard, nsIClipboard, nsIObserver)
 
 nsresult nsClipboard::Init(void) {
-  if (widget::GdkIsX11Display()) {
-    mContext = new nsRetrievalContextX11();
-#if defined(MOZ_WAYLAND)
-  } else if (widget::GdkIsWaylandDisplay()) {
+  if (widget::GdkIsWaylandDisplay()) {
     if (StaticPrefs::widget_wayland_async_clipboard_enabled_AtStartup()) {
       mContext = new nsRetrievalContextWaylandAsync();
     } else {
       mContext = new nsRetrievalContextWayland();
     }
-#endif
   } else {
     NS_WARNING("Missing nsRetrievalContext for nsClipboard!");
     return NS_OK;
@@ -353,11 +347,6 @@ nsClipboard::GetData(nsITransferable* aTransferable, int32_t aWhichClipboard) {
 
   // Filter out MIME types on X11 to prevent unwanted conversions,
   // see Bug 1611407
-  if (widget::GdkIsX11Display()) {
-    if (!FilterImportedFlavors(aWhichClipboard, flavors)) {
-      return NS_OK;
-    }
-  }
 
   for (uint32_t i = 0; i < flavors.Length(); i++) {
     nsCString& flavorStr = flavors[i];
diff --git a/widget/gtk/nsDragService.cpp b/widget/gtk/nsDragService.cpp
index fcd4236261..890c67d860 100644
--- a/widget/gtk/nsDragService.cpp
+++ b/widget/gtk/nsDragService.cpp
@@ -23,7 +23,7 @@
 #include "prthread.h"
 #include <dlfcn.h>
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
 #include "nsCRT.h"
 #include "mozilla/BasicEvents.h"
 #include "mozilla/Services.h"
@@ -34,7 +34,6 @@
 #include "mozilla/WidgetUtilsGtk.h"
 #include "GRefPtr.h"
 
-#include "gfxXlibSurface.h"
 #include "gfxContext.h"
 #include "nsImageToPixbuf.h"
 #include "nsPresContext.h"
diff --git a/widget/gtk/nsGtkKeyUtils.cpp b/widget/gtk/nsGtkKeyUtils.cpp
index f4c7030a37..ae5d75671e 100644
--- a/widget/gtk/nsGtkKeyUtils.cpp
+++ b/widget/gtk/nsGtkKeyUtils.cpp
@@ -12,10 +12,9 @@
 #include <gdk/gdkkeysyms.h>
 #include <algorithm>
 #include <gdk/gdk.h>
-#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
 #include <dlfcn.h>
 #include <gdk/gdkkeysyms-compat.h>
-#include <X11/XKBlib.h>
 #include "X11UndefineNone.h"
 #include "IMContextWrapper.h"
 #include "WidgetUtils.h"
@@ -51,7 +50,7 @@ LazyLogModule gKeymapWrapperLog("KeymapWrapperWidgets");
 
 KeymapWrapper* KeymapWrapper::sInstance = nullptr;
 guint KeymapWrapper::sLastRepeatableHardwareKeyCode = 0;
-Time KeymapWrapper::sLastRepeatableKeyTime = 0;
+GTime KeymapWrapper::sLastRepeatableKeyTime = 0;
 KeymapWrapper::RepeatState KeymapWrapper::sRepeatState =
     KeymapWrapper::NOT_PRESSED;
 
@@ -346,9 +345,6 @@ KeymapWrapper::KeymapWrapper()
 
   g_object_ref(mGdkKeymap);
 
-  if (GdkIsX11Display()) {
-    InitXKBExtension();
-  }
 
   Init();
 }
@@ -365,16 +361,10 @@ void KeymapWrapper::Init() {
   mModifierKeys.Clear();
   memset(mModifierMasks, 0, sizeof(mModifierMasks));
 
-  if (GdkIsX11Display()) {
-    InitBySystemSettingsX11();
-  }
 #ifdef MOZ_WAYLAND
-  else {
     InitBySystemSettingsWayland();
-  }
 #endif
 
-  gdk_window_add_filter(nullptr, FilterEvents, this);
 
   MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
           ("%p Init, CapsLock=0x%X, NumLock=0x%X, "
@@ -387,6 +377,7 @@ void KeymapWrapper::Init() {
            GetModifierMask(SUPER), GetModifierMask(HYPER)));
 }
 
+#ifdef MOZ_X11
 void KeymapWrapper::InitXKBExtension() {
   PodZero(&mKeyboardState);
 
@@ -619,6 +610,7 @@ void KeymapWrapper::InitBySystemSettingsX11() {
   XFreeModifiermap(xmodmap);
   XFree(xkeymap);
 }
+#endif
 
 #ifdef MOZ_WAYLAND
 void KeymapWrapper::SetModifierMask(xkb_keymap* aKeymap,
@@ -776,7 +768,6 @@ void KeymapWrapper::InitBySystemSettingsWayland() {
 #endif
 
 KeymapWrapper::~KeymapWrapper() {
-  gdk_window_remove_filter(nullptr, FilterEvents, this);
   if (mOnKeysChangedSignalHandle) {
     g_signal_handler_disconnect(mGdkKeymap, mOnKeysChangedSignalHandle);
   }
@@ -787,6 +778,7 @@ KeymapWrapper::~KeymapWrapper() {
   MOZ_LOG(gKeymapWrapperLog, LogLevel::Info, ("%p Destructor", this));
 }
 
+#ifdef MOZ_X11
 /* static */
 GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
                                             GdkEvent* aGdkEvent,
@@ -900,6 +892,7 @@ GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
 
   return GDK_FILTER_CONTINUE;
 }
+#endif
 
 static void ResetBidiKeyboard() {
   // Reset the bidi keyboard settings for the new GdkKeymap
@@ -1760,6 +1753,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
   // state.  It means if there're some pending modifier key press or
   // key release events, the result isn't what we want.
   guint modifierState = aGdkKeyEvent->state;
+#ifdef MOZ_X11
   GdkDisplay* gdkDisplay = gdk_display_get_default();
   if (aGdkKeyEvent->is_modifier && GdkIsX11Display(gdkDisplay)) {
     Display* display = gdk_x11_display_get_xdisplay(gdkDisplay);
@@ -1777,6 +1771,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
       }
     }
   }
+#endif
   InitInputEvent(aKeyEvent, modifierState);
 
   switch (aGdkKeyEvent->keyval) {
@@ -2023,6 +2018,7 @@ bool KeymapWrapper::IsLatinGroup(guint8 aGroup) {
   return result;
 }
 
+#ifdef MOZ_X11
 bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
   uint8_t indexOfArray = aHardwareKeyCode / 8;
   MOZ_ASSERT(indexOfArray < ArrayLength(mKeyboardState.auto_repeats),
@@ -2030,6 +2026,7 @@ bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
   char bitMask = 1 << (aHardwareKeyCode % 8);
   return (mKeyboardState.auto_repeats[indexOfArray] & bitMask) != 0;
 }
+#endif
 
 /* static */
 bool KeymapWrapper::IsBasicLatinLetterOrNumeral(uint32_t aCharCode) {
diff --git a/widget/gtk/nsGtkKeyUtils.h b/widget/gtk/nsGtkKeyUtils.h
index 07d60c27a6..58b30cc959 100644
--- a/widget/gtk/nsGtkKeyUtils.h
+++ b/widget/gtk/nsGtkKeyUtils.h
@@ -13,7 +13,6 @@
 #include "nsTArray.h"
 
 #include <gdk/gdk.h>
-#include <X11/XKBlib.h>
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdkwayland.h>
 #  include <xkbcommon/xkbcommon.h>
@@ -315,7 +314,6 @@ class KeymapWrapper {
    * See a call of XkbSelectEventDetails() with XkbControlsNotify in
    * InitXKBExtension().
    */
-  XKeyboardState mKeyboardState;
 
   /**
    * Pointer of the singleton instance.
@@ -326,7 +324,7 @@ class KeymapWrapper {
    * Auto key repeat management.
    */
   static guint sLastRepeatableHardwareKeyCode;
-  static Time sLastRepeatableKeyTime;
+  static GTime sLastRepeatableKeyTime;
   enum RepeatState { NOT_PRESSED, FIRST_PRESS, REPEATING };
   static RepeatState sRepeatState;
 
diff --git a/widget/gtk/nsPrintDialogGTK.cpp b/widget/gtk/nsPrintDialogGTK.cpp
index 0050af3af3..ae7d83f391 100644
--- a/widget/gtk/nsPrintDialogGTK.cpp
+++ b/widget/gtk/nsPrintDialogGTK.cpp
@@ -26,7 +26,7 @@
 #include "nsIObserverService.h"
 
 // for gdk_x11_window_get_xid
-#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -525,6 +525,7 @@ static void wayland_window_handle_exported(GdkWindow* window,
 static gboolean window_export_handle(GtkWindow* window,
                                      GtkWindowHandleExported callback,
                                      gpointer user_data) {
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window));
     char* handle_str;
@@ -535,8 +536,9 @@ static gboolean window_export_handle(GtkWindow* window,
     g_free(handle_str);
     return true;
   }
+#endif
 #ifdef MOZ_WAYLAND
-  else if (GdkIsWaylandDisplay()) {
+  if (GdkIsWaylandDisplay()) {
     GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window));
     WaylandWindowHandleExportedData* data;
 
diff --git a/widget/gtk/nsUserIdleServiceGTK.cpp b/widget/gtk/nsUserIdleServiceGTK.cpp
index 884d52a6ca..b6dfc813fa 100644
--- a/widget/gtk/nsUserIdleServiceGTK.cpp
+++ b/widget/gtk/nsUserIdleServiceGTK.cpp
@@ -17,6 +17,7 @@ using mozilla::LogLevel;
 
 static mozilla::LazyLogModule sIdleLog("nsIUserIdleService");
 
+#ifdef MOZ_X11
 typedef bool (*_XScreenSaverQueryExtension_fn)(Display* dpy, int* event_base,
                                                int* error_base);
 
@@ -25,12 +26,14 @@ typedef XScreenSaverInfo* (*_XScreenSaverAllocInfo_fn)(void);
 typedef void (*_XScreenSaverQueryInfo_fn)(Display* dpy, Drawable drw,
                                           XScreenSaverInfo* info);
 
-static bool sInitialized = false;
 static _XScreenSaverQueryExtension_fn _XSSQueryExtension = nullptr;
 static _XScreenSaverAllocInfo_fn _XSSAllocInfo = nullptr;
 static _XScreenSaverQueryInfo_fn _XSSQueryInfo = nullptr;
+#endif
+static bool sInitialized = false;
 
 static void Initialize() {
+#ifdef MOZ_X11
   if (!mozilla::widget::GdkIsX11Display()) {
     return;
   }
@@ -57,16 +60,15 @@ static void Initialize() {
     MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSAllocInfo!\n"));
   if (!_XSSQueryInfo)
     MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSQueryInfo!\n"));
-
+#endif
   sInitialized = true;
 }
 
-nsUserIdleServiceGTK::nsUserIdleServiceGTK() : mXssInfo(nullptr) {
+nsUserIdleServiceGTK::nsUserIdleServiceGTK() {
   Initialize();
 }
 
 nsUserIdleServiceGTK::~nsUserIdleServiceGTK() {
-  if (mXssInfo) XFree(mXssInfo);
 
 // It is not safe to unload libXScrnSaver until each display is closed because
 // the library registers callbacks through XESetCloseDisplay (Bug 397607).
@@ -85,6 +87,7 @@ bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
     return false;
   }
 
+#ifdef MOZ_X11
   // Ask xscreensaver about idle time:
   *aIdleTime = 0;
 
@@ -107,6 +110,7 @@ bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
     *aIdleTime = mXssInfo->idle;
     return true;
   }
+#endif
   // If we get here, we couldn't get to XScreenSaver:
   MOZ_LOG(sIdleLog, LogLevel::Warning, ("XSSQueryExtension returned false!\n"));
   return false;
diff --git a/widget/gtk/nsUserIdleServiceGTK.h b/widget/gtk/nsUserIdleServiceGTK.h
index 9b9ba31846..001f31a3a9 100644
--- a/widget/gtk/nsUserIdleServiceGTK.h
+++ b/widget/gtk/nsUserIdleServiceGTK.h
@@ -9,6 +9,7 @@
 #define nsUserIdleServiceGTK_h__
 
 #include "nsUserIdleService.h"
+#ifdef MOZ_X11
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #include <gdk/gdkx.h>
@@ -21,7 +22,7 @@ typedef struct {
   unsigned long idle;          // milliseconds idle
   unsigned long event_mask;    // event stuff
 } XScreenSaverInfo;
-
+#endif
 class nsUserIdleServiceGTK : public nsUserIdleService {
  public:
   NS_INLINE_DECL_REFCOUNTING_INHERITED(nsUserIdleServiceGTK, nsUserIdleService)
@@ -40,7 +41,6 @@ class nsUserIdleServiceGTK : public nsUserIdleService {
 
  private:
   ~nsUserIdleServiceGTK();
-  XScreenSaverInfo* mXssInfo;
 
  protected:
   nsUserIdleServiceGTK();
diff --git a/widget/gtk/nsWidgetFactory.cpp b/widget/gtk/nsWidgetFactory.cpp
index d649c7e0bf..2f0f6223a4 100644
--- a/widget/gtk/nsWidgetFactory.cpp
+++ b/widget/gtk/nsWidgetFactory.cpp
@@ -20,9 +20,7 @@
 #include "nsHTMLFormatConverter.h"
 #include "HeadlessClipboard.h"
 #include "IMContextWrapper.h"
-#ifdef MOZ_X11
 #  include "nsClipboard.h"
-#endif
 #include "TaskbarProgress.h"
 #include "nsFilePicker.h"
 #include "nsSound.h"
@@ -36,7 +34,6 @@
 using namespace mozilla;
 using namespace mozilla::widget;
 
-#ifdef MOZ_X11
 NS_IMPL_COMPONENT_FACTORY(nsIClipboard) {
   nsCOMPtr<nsIClipboard> inst;
   if (gfxPlatform::IsHeadless()) {
@@ -51,7 +48,6 @@ NS_IMPL_COMPONENT_FACTORY(nsIClipboard) {
 
   return inst.forget().downcast<nsISupports>();
 }
-#endif
 
 nsresult nsWidgetGtk2ModuleCtor() { return nsAppShellInit(); }
 
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index 620e2f47f2..6de82c3b36 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -58,7 +58,6 @@
 #include "mozilla/UniquePtrExtensions.h"
 #include "mozilla/WidgetUtils.h"
 #include "mozilla/WritingModes.h"
-#include "mozilla/X11Util.h"
 #include "mozilla/XREAppData.h"
 #include "NativeKeyBindings.h"
 #include "nsAppDirectoryServiceDefs.h"
@@ -90,7 +89,6 @@
 #include "ScreenHelperGTK.h"
 #include "SystemTimeConverter.h"
 #include "WidgetUtilsGtk.h"
-#include "mozilla/X11Util.h"
 
 #ifdef ACCESSIBILITY
 #  include "mozilla/a11y/LocalAccessible.h"
@@ -105,11 +103,13 @@
 #  include <X11/extensions/shape.h>
 #  include "gfxXlibSurface.h"
 #  include "GLContextGLX.h"  // for GLContextGLX::FindVisual()
-#  include "GLContextEGL.h"  // for GLContextEGL::FindVisual()
 #  include "WindowSurfaceX11Image.h"
 #  include "WindowSurfaceX11SHM.h"
 #endif
+#  include "GLContextEGL.h"  // for GLContextEGL::FindVisual()
 #ifdef MOZ_WAYLAND
+#  include <gdk/gdk.h>
+#  include <gdk/gdkkeysyms-compat.h>
 #  include "nsIClipboard.h"
 #  include "nsView.h"
 #endif
@@ -119,7 +119,6 @@ using namespace mozilla::gfx;
 using namespace mozilla::layers;
 using namespace mozilla::widget;
 using mozilla::gl::GLContextEGL;
-using mozilla::gl::GLContextGLX;
 
 // Don't put more than this many rects in the dirty region, just fluff
 // out to the bounding-box if there are more
@@ -275,7 +274,7 @@ static SystemTimeConverter<guint32>& TimeConverter() {
 bool nsWindow::sTransparentMainWindow = false;
 
 namespace mozilla {
-
+#ifdef MOZ_X11
 class CurrentX11TimeGetter {
  public:
   explicit CurrentX11TimeGetter(GdkWindow* aWindow)
@@ -323,6 +322,7 @@ class CurrentX11TimeGetter {
   GdkWindow* mWindow;
   TimeStamp mAsyncUpdateStart;
 };
+#endif
 
 }  // namespace mozilla
 
@@ -2526,6 +2526,7 @@ void nsWindow::SetSizeMode(nsSizeMode aMode) {
 }
 
 static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
+#ifdef MOZ_X11
   if (!GdkIsX11Display()) {
     return false;
   }
@@ -2592,6 +2593,7 @@ static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
   }
 
   wmName = reinterpret_cast<const char*>(prop_return);
+#endif
   return true;
 }
 
@@ -2646,12 +2648,9 @@ static bool WorkspaceManagementDisabled(GdkWindow* gdk_window) {
 void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
   workspaceID.Truncate();
 
-  if (!GdkIsX11Display() || !mShell) {
-    return;
-  }
 
   LOG("nsWindow::GetWorkspaceID()\n");
-
+#ifdef MOZ_X11
   // Get the gdk window for this widget.
   GdkWindow* gdk_window = gtk_widget_get_window(mShell);
   if (!gdk_window) {
@@ -2684,9 +2683,11 @@ void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
   LOG("  got workspace ID %d", (int32_t)wm_desktop[0]);
   workspaceID.AppendInt((int32_t)wm_desktop[0]);
   g_free(wm_desktop);
+#endif
 }
 
 void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
+#ifdef MOZ_X11
   nsresult rv = NS_OK;
   int32_t workspaceID = workspaceIDStr.ToInteger(&rv);
 
@@ -2731,6 +2732,7 @@ void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
 
   XFlush(xdisplay);
   LOG("  moved to workspace");
+#endif
 }
 
 using SetUserTimeFunc = void (*)(GdkWindow*, guint32);
@@ -2771,9 +2773,7 @@ guint32 nsWindow::GetLastUserInputTime() {
   // button and key releases.  Therefore use the most recent of
   // gdk_x11_display_get_user_time and the last time that we have seen.
   GdkDisplay* gdkDisplay = gdk_display_get_default();
-  guint32 timestamp = GdkIsX11Display(gdkDisplay)
-                          ? gdk_x11_display_get_user_time(gdkDisplay)
-                          : gtk_get_current_event_time();
+  guint32 timestamp = gtk_get_current_event_time();
 
   if (sLastUserInputTime != GDK_CURRENT_TIME &&
       TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
@@ -2936,7 +2936,7 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
     mClientOffset = nsIntPoint(0, 0);
     return;
   }
-
+#ifdef MOZ_X11
   GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
 
   GdkAtom type_returned;
@@ -2962,7 +2962,7 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
 
     mClientOffset = nsIntPoint(left, top);
   }
-
+#endif
   // Send a WindowMoved notification. This ensures that BrowserParent
   // picks up the new client offset and sends it to the child process
   // if appropriate.
@@ -2973,13 +2973,12 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
 }
 
 LayoutDeviceIntPoint nsWindow::GetClientOffset() {
-  return GdkIsX11Display()
-             ? LayoutDeviceIntPoint::FromUnknownPoint(mClientOffset)
-             : LayoutDeviceIntPoint(0, 0);
+  return LayoutDeviceIntPoint(0, 0);
 }
 
 gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
                                          GdkEventProperty* aEvent) {
+#ifdef MOZ_X11
   if (aEvent->atom == gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE)) {
     UpdateClientOffsetFromFrameExtents();
     return FALSE;
@@ -2990,6 +2989,7 @@ gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
   if (GetCurrentTimeGetter()->PropertyNotifyHandler(aWidget, aEvent)) {
     return TRUE;
   }
+#endif
   return FALSE;
 }
 
@@ -3127,9 +3127,11 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
       return GetToplevelWidget();
 
     case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID:
+#ifdef MOZ_X11
       if (GdkIsX11Display()) {
         return (void*)GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
       }
+#endif
       NS_WARNING(
           "nsWindow::GetNativeData(): NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID is not "
           "handled on Wayland!");
@@ -3150,14 +3152,14 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
       return nullptr;
     case NS_NATIVE_EGL_WINDOW: {
       void* eglWindow = nullptr;
+#ifdef MOZ_X11
       if (GdkIsX11Display()) {
         eglWindow = mGdkWindow ? (void*)GDK_WINDOW_XID(mGdkWindow) : nullptr;
       }
+#endif
 #ifdef MOZ_WAYLAND
-      else {
         eglWindow = moz_container_wayland_get_egl_window(
             mContainer, FractionalScaleFactor());
-      }
 #endif
       LOG("Get NS_NATIVE_EGL_WINDOW window %p", eglWindow);
       return eglWindow;
@@ -3478,7 +3480,7 @@ gboolean nsWindow::OnExposeEvent(cairo_t* cr) {
   if (!listener) return FALSE;
 
   LOG("received expose event %p 0x%lx (rects follow):\n", mGdkWindow,
-      GdkIsX11Display() ? gdk_x11_window_get_xid(mGdkWindow) : 0);
+      0);
   LayoutDeviceIntRegion exposeRegion;
   if (!ExtractExposeRegion(exposeRegion, cr)) {
     return FALSE;
@@ -3836,7 +3838,7 @@ void nsWindow::OnSizeAllocate(GtkAllocation* aAllocation) {
   // we don't get _NET_FRAME_EXTENTS X11 property notification so we derive
   // it from mContainer position.
   if (mGtkWindowDecoration == GTK_DECORATION_CLIENT) {
-    if (GdkIsWaylandDisplay() || (GdkIsX11Display() && mDrawInTitlebar)) {
+    if (GdkIsWaylandDisplay()) {
       UpdateClientOffsetFromCSDWindow();
     }
   }
@@ -4020,6 +4022,7 @@ void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
     MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
 
     bool canDrag = true;
+#ifdef MOZ_X11
     if (GdkIsX11Display()) {
       // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
       // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -4030,7 +4033,7 @@ void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
         canDrag = false;
       }
     }
-
+#endif
     if (canDrag) {
       gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root, aEvent->y_root,
                                  aEvent->time);
@@ -4472,7 +4475,6 @@ TimeStamp nsWindow::GetEventTimeStamp(guint32 aEventTime) {
 
   TimeStamp eventTimeStamp;
 
-  if (GdkIsWaylandDisplay()) {
     // Wayland compositors use monotonic time to set timestamps.
     int64_t timestampTime = g_get_monotonic_time() / 1000;
     guint32 refTimeTruncated = guint32(timestampTime);
@@ -4481,16 +4483,9 @@ TimeStamp nsWindow::GetEventTimeStamp(guint32 aEventTime) {
     int64_t tick =
         BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
     eventTimeStamp = TimeStamp::FromSystemTime(tick);
-  } else {
-    CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
-    MOZ_ASSERT(getCurrentTime,
-               "Null current time getter despite having a window");
-    eventTimeStamp =
-        TimeConverter().GetTimeStampFromSystemTime(aEventTime, *getCurrentTime);
-  }
   return eventTimeStamp;
 }
-
+#ifdef MOZ_X11
 mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
   if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
@@ -4498,7 +4493,7 @@ mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   }
   return mCurrentTimeGetter.get();
 }
-
+#endif
 gboolean nsWindow::OnKeyPressEvent(GdkEventKey* aEvent) {
   LOG("OnKeyPressEvent [%p]\n", (void*)this);
 
@@ -4666,6 +4661,7 @@ void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
   //
   // This may be fixed in Gtk 3.24+ but some DE still have this issue
   // (Bug 1624199) so let's remove it for Wayland only.
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     if (!mIsShown) {
       aEvent->changed_mask = static_cast<GdkWindowState>(
@@ -4676,7 +4672,7 @@ void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
           aEvent->changed_mask | GDK_WINDOW_STATE_MAXIMIZED);
     }
   }
-
+#endif
   // This is a workaround for https://gitlab.gnome.org/GNOME/gtk/issues/1395
   // Gtk+ controls window active appearance by window-state-event signal.
   if (IsChromeWindowTitlebar() &&
@@ -5160,9 +5156,6 @@ static void GtkWidgetDisableUpdates(GtkWidget* aWidget) {
 void nsWindow::EnableRenderingToWindow() {
   LOG("nsWindow::EnableRenderingToWindow()");
 
-  if (mCompositorWidgetDelegate) {
-    mCompositorWidgetDelegate->EnableRendering(mXWindow, mIsShaped);
-  }
 
   if (GdkIsWaylandDisplay()) {
 #ifdef MOZ_WAYLAND
@@ -5259,7 +5252,7 @@ void nsWindow::ConfigureGdkWindow() {
   }
 
   LOG("  finished, new GdkWindow %p XID 0x%lx\n", mGdkWindow,
-      GdkIsX11Display() ? gdk_x11_window_get_xid(mGdkWindow) : 0);
+      0);
 }
 
 void nsWindow::ReleaseGdkWindow() {
@@ -5389,9 +5382,6 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
       if (mWindowType == eWindowType_popup) {
         MOZ_ASSERT(aInitData);
         type = GTK_WINDOW_POPUP;
-        if (GdkIsX11Display() && mNoAutoHide) {
-          type = GTK_WINDOW_TOPLEVEL;
-        }
       }
       mShell = gtk_window_new(type);
 
@@ -5512,6 +5502,7 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
                                    GDK_WINDOW_TYPE_HINT_DND);
           mIsDragPopup = true;
           LOG_POPUP("nsWindow::Create() Drag popup [%p]\n", this);
+#ifdef MOZ_X11
         } else if (GdkIsX11Display()) {
           // Set the window hints on X11 only. Wayland popups are configured
           // at WaylandPopupNeedsTrackInHierarchy().
@@ -5530,6 +5521,7 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
           gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
           LOG_POPUP("nsWindow::Create() popup type %s\n",
                     GetPopupTypeName().get());
+#endif
         }
         if (parentnsWindow) {
           LOG_POPUP("    set parent window [%p] %s\n", parentnsWindow,
@@ -5543,13 +5535,14 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
 
         // We need realized mShell at NativeMoveResize().
         gtk_widget_realize(mShell);
-
+#ifdef MOZ_X11
         if (GdkIsX11Display()) {
           // With popup windows, we want to control their position, so don't
           // wait for the window manager to place them (which wouldn't
           // happen with override-redirect windows anyway).
           NativeMoveResize(/* move */ true, /* resize */ false);
         }
+#endif
       } else {  // must be eWindowType_toplevel
         mGtkWindowRoleName = "Toplevel";
         SetDefaultIcon();
@@ -5806,8 +5799,7 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
       mIsPIPWindow ? "PIP window" : "");
   LOG("\tmShell %p mContainer %p mGdkWindow %p XID 0x%lx\n", mShell, mContainer,
       mGdkWindow,
-      (GdkIsX11Display() && mGdkWindow) ? gdk_x11_window_get_xid(mGdkWindow)
-                                        : 0);
+      0);
 
   // Set default application name when it's empty.
   if (mGtkWindowAppName.IsEmpty()) {
@@ -5914,12 +5906,14 @@ void nsWindow::NativeMoveResize(bool aMoved, bool aResized) {
 
   // Set position to hidden window on X11 may fail, so save the position
   // and move it when it's shown.
+#ifdef MOZ_X11
   if (aMoved && GdkIsX11Display() && IsPopup() &&
       !gtk_widget_get_visible(GTK_WIDGET(mShell))) {
     LOG("  store position of hidden popup window");
     mHiddenPopupPositioned = true;
     mPopupPosition = topLeft;
   }
+#endif
 
   if (IsWaylandPopup()) {
     NativeMoveResizeWaylandPopup(aMoved, aResized);
@@ -6654,7 +6648,7 @@ void nsWindow::UpdateTitlebarTransparencyBitmap() {
 
     cairo_surface_destroy(surface);
   }
-
+#ifdef MOZ_X11
   if (!mNeedsShow) {
     Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
     Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
@@ -6675,6 +6669,7 @@ void nsWindow::UpdateTitlebarTransparencyBitmap() {
 
     XFreePixmap(xDisplay, maskPixmap);
   }
+#endif
 }
 
 void nsWindow::GrabPointer(guint32 aTime) {
@@ -6949,18 +6944,18 @@ static bool IsFullscreenSupported(GtkWidget* aShell) {
   GdkScreen* screen = gtk_widget_get_screen(aShell);
   GdkAtom atom = gdk_atom_intern("_NET_WM_STATE_FULLSCREEN", FALSE);
   return gdk_x11_screen_supports_net_wm_hint(screen, atom);
-#elif
+#else
   return true;
 #endif
 }
 
 nsresult nsWindow::MakeFullScreen(bool aFullScreen, nsIScreen* aTargetScreen) {
   LOG("nsWindow::MakeFullScreen aFullScreen %d\n", aFullScreen);
-
+#ifdef MOZ_X11
   if (GdkIsX11Display() && !IsFullscreenSupported(mShell)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
-
+#endif
   bool wasFullscreen = mSizeState == nsSizeMode_Fullscreen;
   if (aFullScreen != wasFullscreen && mWidgetListener) {
     mWidgetListener->FullscreenWillChange(aFullScreen);
@@ -8214,7 +8209,7 @@ bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
   if (!aMouseEvent->mWidget) {
     return false;
   }
-
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
     // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -8230,7 +8225,7 @@ bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
       }
     }
   }
-
+#endif
   // FIXME: It would be nice to have the widget position at the time
   // of the event, but it's relatively unlikely that the widget has
   // moved since the mousedown.  (On the other hand, it's quite likely
@@ -8896,23 +8891,11 @@ nsWindow::GtkWindowDecoration nsWindow::GetSystemGtkWindowDecoration() {
 bool nsWindow::TitlebarUseShapeMask() {
   static int useShapeMask = []() {
     // Don't use titlebar shape mask on Wayland
-    if (!GdkIsX11Display()) {
       return false;
-    }
 
     // We can't use shape masks on Mutter/X.org as we can't resize Firefox
     // window there (Bug 1530252).
-    const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
-    if (currentDesktop) {
-      if (strstr(currentDesktop, "GNOME") != nullptr) {
-        const char* sessionType = getenv("XDG_SESSION_TYPE");
-        if (sessionType && strstr(sessionType, "x11") != nullptr) {
-          return false;
-        }
-      }
-    }
 
-    return Preferences::GetBool("widget.titlebar-x11-use-shape-mask", false);
   }();
   return useShapeMask;
 }
@@ -8943,8 +8926,8 @@ void nsWindow::GetCompositorWidgetInitData(
   }
 #endif
   *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
-      (mXWindow != X11None) ? mXWindow : (uintptr_t) nullptr, displayName,
-      mIsShaped, GdkIsX11Display(), GetClientSize());
+      (uintptr_t) nullptr, nsCString(),
+      0, 0, GetClientSize());
 }
 
 #ifdef MOZ_X11
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index 74d914328e..d0711e3726 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -95,7 +95,6 @@ typedef struct _GdkEventTouchpadPinch GdkEventTouchpadPinch;
 
 namespace mozilla {
 class TimeStamp;
-class CurrentX11TimeGetter;
 
 }  // namespace mozilla
 
@@ -277,7 +276,6 @@ class nsWindow final : public nsBaseWidget {
 
   WidgetEventTime GetWidgetEventTime(guint32 aEventTime);
   mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
-  mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
 
   virtual void SetInputContext(const InputContext& aContext,
                                const InputContextAction& aAction) override;
@@ -819,7 +817,6 @@ class nsWindow final : public nsBaseWidget {
    */
   RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
 
-  mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
   static GtkWindowDecoration sGtkWindowDecoration;
 
   static bool sTransparentMainWindow;
diff --git a/widget/moz.build b/widget/moz.build
index 4724d667d8..48d0b4b1b6 100644
--- a/widget/moz.build
+++ b/widget/moz.build
@@ -262,7 +262,7 @@ if CONFIG["MOZ_INSTRUMENT_EVENT_LOOP"]:
 
 EXPORTS.ipc = ["nsGUIEventIPC.h"]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     DIRS += ["x11"]
 
 if toolkit in ("cocoa", "windows"):
@@ -309,7 +309,7 @@ if toolkit == "windows":
         "windows/PCompositorWidget.ipdl",
         "windows/PlatformWidgetTypes.ipdlh",
     ]
-elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk" and CONFIG["MOZ_X11"]:
+elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     IPDL_SOURCES = [
         "gtk/PCompositorWidget.ipdl",
         "gtk/PlatformWidgetTypes.ipdlh",
